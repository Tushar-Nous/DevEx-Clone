// Lyzr placeholder implementation replacing Azure OpenAI client
import { personaService } from "./personaService";
import { API_ENDPOINTS } from "../config/api";

let llm = {
  invoke: async (prompt) => ({
    content: JSON.stringify({
      title: "Generated by Lyzr",
      description: String(prompt).slice(0, 200),
      tags: ["lyzr"],
      priority: "medium",
    }),
  }),
};

export const fetchGuidelines = async (input) => {
  const response = await fetch(API_ENDPOINTS.generateGuidelines, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ input }),
  });
  if (!response.ok) throw new Error("Failed to fetch guidelines");
  return response.json();
};

// Anti-hallucination system prompt
const ANTI_HALLUCINATION_PROMPT = `
You are an AI assistant specialized in software development lifecycle (SDLC) for insurance domain applications. 
IMPORTANT: Only generate content based on the information provided. Do not make up or assume any details that are not explicitly mentioned in the input.
If you need to make assumptions, clearly state them and mark them as such.
Always focus on practical, implementable solutions for insurance industry software development.
`;

export const generateRequirementSummary = async (content, fileName) => {
  try {
    if (!llm) {
      // Azure OpenAI client not available, using fallback response
      return {
        title: fileName || "Insurance Requirement",
        description: content.substring(0, 200) + "...",
        tags: ["insurance", "requirement"],
        priority: "medium",
      };
    }

    console.log("Using Lyzr for requirement summary generation");

    const prompt = `
${ANTI_HALLUCINATION_PROMPT}

Analyze the following insurance domain requirement content and provide a structured summary:

Content: ${content}
File: ${fileName}

Please provide:
1. A clear, concise title (max 100 characters)
2. A detailed description (max 500 characters)
3. Relevant tags (insurance, claims, policy, etc.)
4. Priority level (high/medium/low) based on business impact

Format your response as JSON:
{
  "title": "string",
  "description": "string", 
  "tags": ["tag1", "tag2"],
  "priority": "high|medium|low"
}
`;

    console.log("Sending prompt to Lyzr...");
    const response = await llm.invoke(prompt);
    console.log("Lyzr response received:", response);

    let result;
    try {
      result = JSON.parse(response.content);
    } catch (parseError) {
      throw new Error("Invalid JSON response from AI service");
    }

    // Validate response structure
    if (
      !result.title ||
      !result.description ||
      !result.tags ||
      !result.priority
    ) {
      throw new Error("Invalid AI response structure");
    }

    console.log("Successfully generated requirement summary:", result);
    return result;
  } catch (error) {
    // Fallback response
    return {
      title: fileName || "Insurance Requirement",
      description: content.substring(0, 200) + "...",
      tags: ["insurance", "requirement"],
      priority: "medium",
    };
  }
};

export const generateEpicsAndFeatures = async (requirement) => {
  try {
    // Load personas for context
    await personaService.initialize();
    const personaList = await personaService.formatPersonasForPrompt();

    const prompt = `
${ANTI_HALLUCINATION_PROMPT}

IMPORTANT: Use ONLY these personas from our organization when generating user stories:

${personaList}

Based on the following insurance domain requirement, generate epics and features following SDLC best practices:

Requirement: ${requirement.title}
Description: ${requirement.description}
Content: ${requirement.content}

Generate:
1. 2-4 epics that represent major functional areas
2. 3-6 features that break down each epic into implementable components

Each epic should:
- Have a clear business objective
- Be large enough to span multiple sprints
- Focus on a specific insurance domain area

Each feature should:
- Be deliverable in 1-2 sprints
- Have clear acceptance criteria
- Support the parent epic's goals
- Use specific persona names from the list above

Format your response as JSON:
{
  "epics": [
    {
      "title": "string",
      "description": "string",
      "priority": "high|medium|low"
    }
  ],
  "features": [
    {
      "title": "string", 
      "description": "string",
      "epicId": "epic1|epic2|epic3",
      "priority": "high|medium|low",
      "relevantPersonas": ["QA Engineer", "Senior Developer"]
    }
  ]
}
`;

    const response = await llm.invoke(prompt);
    const result = JSON.parse(response.content);

    // Validate response structure
    if (
      !result.epics ||
      !result.features ||
      !Array.isArray(result.epics) ||
      !Array.isArray(result.features)
    ) {
      throw new Error("Invalid AI response structure for epics and features");
    }

    return result;
  } catch (error) {
    console.error("Error generating epics and features:", error);
    // Fallback response
    return {
      epics: [
        {
          title: "Core Insurance Platform",
          description: "Fundamental insurance system functionality",
          priority: "high",
        },
      ],
      features: [
        {
          title: "User Management",
          description: "Basic user authentication and authorization",
          epicId: "epic1",
          priority: "high",
          relevantPersonas: ["Senior Developer", "Security Analyst"],
        },
      ],
    };
  }
};

export const generateUserStories = async (feature, requirement) => {
  try {
    // Load personas for context
    await personaService.initialize();
    const personaList = await personaService.formatPersonasForPrompt();
    const personas = await personaService.getAllPersonas();
    console.log("personaList:", personaList);
    const prompt = `
${ANTI_HALLUCINATION_PROMPT}

SYSTEM CONTEXT:
You are a senior Agile consultant and domain expert helping generate user stories.

DOMAIN CONTEXT:
Insurance technology â€” includes policy management, claims processing, underwriting, payments, and user portals.

CRITICAL INSTRUCTION:
Use ONLY these personas (no variations or abbreviations):
${personaList}

If multiple personas could apply, choose the one most directly responsible for implementation, validation, or delivery.

FORMAT REQUIREMENTS:
- Use the structure: "As a [Exact Persona Name], I want [goal] so that [benefit]"
- Each user story must include:
  â€¢ description (concise explanation)
  â€¢ persona (Exact Persona Name)
  â€¢ acceptanceCriteria (3â€“5 realistic testable criteria in Given/When/Then format)
  â€¢ priority (high|medium|low)
  â€¢ storyPoints (1, 2, 3, 5, 8, 13, or 21)
- Keep output strictly JSON with no explanations or markdown.

FEW-SHOT EXAMPLES:
âœ… "As a QA Engineer, I want to automate regression tests so that we reduce testing time."
âœ… "As a Senior Developer, I want to optimize API performance so that response time improves for underwriting workflows."
âœ… "As a DevOps Engineer, I want to enable rollback automation so that deployments are reliable."
âœ… "As a Product Manager, I want to track claim submission funnel metrics so that we can identify drop-offs."
âœ… "As a Security Analyst, I want to perform vulnerability scans on policy data endpoints so that customer information remains secure."

INPUT FEATURE:
Feature: ${feature.title}
Feature Description: ${feature.description}

INPUT REQUIREMENT:
Requirement: ${requirement.title}
Requirement Description: ${requirement.description}

OUTPUT FORMAT:
{
  "userStories": [
    {
      "title": "As a [Exact Persona Name], I want [goal] so that [benefit]",
      "description": "string",
      "persona": "Exact Persona Name",
      "acceptanceCriteria": [
        "Given [context], when [action], then [expected result]"
      ],
      "priority": "high|medium|low",
      "storyPoints": 3
    }
  ]
}
`;

    const response = await llm.invoke(prompt);
    const result = JSON.parse(response.content);

    // Validate response structure
    if (!result.userStories || !Array.isArray(result.userStories)) {
      throw new Error("Invalid AI response structure for user stories");
    }

    // Validate and enhance each user story with persona information
    result.userStories = result.userStories.map((story) => {
      // Extract persona from story title
      const personaMatch = story.title?.match(/As (?:a |an )?([^,]+),/i);

      if (personaMatch) {
        const extractedPersona = personaMatch[1].trim();
        const matchingPersona = personas.find(
          (p) => p.name.toLowerCase() === extractedPersona.toLowerCase()
        );

        if (!matchingPersona) {
          // If persona doesn't match, assign a relevant one
          console.warn(
            `âš ï¸  Invalid persona detected: "${extractedPersona}". Finding relevant persona...`
          );
          const relevantPersona = personaService.findRelevantPersona(
            story,
            personas
          );
          story.title = story.title.replace(
            personaMatch[0],
            `As a ${relevantPersona.name},`
          );
          story.persona = relevantPersona.name;
          story.personaId = relevantPersona.id;
          console.log(`âœ… Replaced with: ${relevantPersona.name}`);
        } else {
          story.persona = matchingPersona.name;
          story.personaId = matchingPersona.id;
        }
      } else {
        // No persona format found, add default
        const relevantPersona = personaService.findRelevantPersona(
          story,
          personas
        );
        story.title = `As a ${relevantPersona.name}, ${story.title}`;
        story.persona = relevantPersona.name;
        story.personaId = relevantPersona.id;
      }

      // // Ensure minimum acceptance criteria
      // if (!story.acceptanceCriteria || story.acceptanceCriteria.length < 3) {
      //   story.acceptanceCriteria = [
      //     ...(story.acceptanceCriteria || []),
      //     "Given the feature is implemented, when the user performs the action, then the expected result occurs",
      //     "The solution is testable and meets quality standards",
      //     "The implementation follows security and performance best practices",
      //   ].slice(0, 5);
      // }
     
story.acceptanceCriteria = story.acceptanceCriteria.filter(c => 
  !/feature is implemented|solution is testable|follows best practices|expected result occurs/i.test(c)
);

// Ensure minimum 3
if (story.acceptanceCriteria.length < 3) {
  story.acceptanceCriteria.push(
    'Given valid inputs, when the process runs, then the expected result should match the business rule',
    'Given edge case inputs, when validated, then appropriate error messages should be shown',
    'Given production conditions, when executed, then the system should maintain reliability and performance standards'
  );
}
      // Adjust story points heuristically based on title/description
if (/integration|architecture|infrastructure|compliance|security/i.test(story.title)) {
  story.storyPoints = Math.max(story.storyPoints || 5, 5);
} else if (/ui|ux|minor|validation|display/i.test(story.title)) {
  story.storyPoints = Math.min(story.storyPoints || 3, 3);
} else if (/automation|optimization|refactor/i.test(story.title)) {
  story.storyPoints = story.storyPoints > 3 ? story.storyPoints : 5;
}

      return story;
    });

    console.log(
      "âœ… Generated user stories with validated personas:",
      result.userStories.map((s) => s.persona)
    );
    return result.userStories;
  } catch (error) {
    console.error("Error generating user stories:", error);
    // Fallback response with valid persona
    await personaService.initialize();
    const personas = await personaService.getAllPersonas();
    const defaultPersona = personas[0] || {
      name: "QA Engineer",
      id: "qa-engineer",
    };

    return [
      {
        title: `As a ${defaultPersona.name}, I want to access the system so that I can perform my tasks`,
        description: "Basic system access functionality",
        persona: defaultPersona.name,
        personaId: defaultPersona.id,
        acceptanceCriteria: [
          "Given valid credentials, when user logs in, then access is granted",
          "The user can navigate to main menu",
          "The system is secure and follows best practices",
        ],
        priority: "medium",
        storyPoints: 3,
      },
    ];
  }
};

export const generatePrompt = async (userStory) => {
  try {
    const prompt = `
${ANTI_HALLUCINATION_PROMPT}

Based on the following user story, generate a comprehensive Enterprise Application Design Guidelines prompt following the established template format:

User Story: ${userStory.title}
Description: ${userStory.description}
Story Points: ${userStory.storyPoints}
Priority: ${userStory.priority}

Generate a detailed prompt that follows this exact structure:

# Enterprise Application Design Guidelines for [Specific Feature/Component]

## Project Overview
[Brief description of what needs to be designed/developed based on the user story]

## 1. Design System Foundation
### Brand Identity
- **Logo Integration**: [Specific requirements]
- **Brand Colors**: [Color specifications]
- **Brand Voice**: [Tone and style requirements]
- **Typography Hierarchy**: [Font specifications]

### Color System
- **Primary Colors**: [Specific color requirements]
- **Semantic Colors**: [Success, Warning, Error, Info specifications]
- **Neutral Palette**: [Gray scale requirements]
- **Contrast Requirements**: [Accessibility standards]

## 2. Typography Guidelines
### Font Selection
- **Primary Font**: [Font family requirements]
- **Font Weights**: [Weight specifications]
- **Line Heights**: [Spacing requirements]
- **Font Sizes**: [Size scale requirements]

### Text Hierarchy
- **H1-H6**: [Specific heading requirements]
- **Body**: [Content text requirements]
- **Caption**: [Supporting text requirements]

## 3. Layout and Grid System
### Grid Structure
- **Desktop**: [Grid specifications]
- **Tablet**: [Responsive requirements]
- **Mobile**: [Mobile-first approach]
- **Container Max-width**: [Layout constraints]

### Spacing System
- **Base Unit**: [Spacing scale]
- **Component Padding**: [Internal spacing]
- **Section Margins**: [Content separation]

## 4. Component Library Specifications
### [Specific Component Type]
- **Requirements**: [Detailed component specifications]
- **States**: [Interactive states needed]
- **Accessibility**: [ARIA and keyboard support]
- **Responsive Behavior**: [Breakpoint behavior]

## 5. Web Accessibility (WCAG 2.1 AA Compliance)
### [Specific accessibility requirements]
- **Contrast Ratios**: [Color accessibility]
- **Keyboard Navigation**: [Navigation support]
- **Screen Reader Support**: [ARIA implementation]

## 6. Responsive Design Principles
### [Responsive requirements]
- **Breakpoints**: [Specific breakpoint needs]
- **Mobile-First**: [Mobile considerations]
- **Touch Interactions**: [Mobile interaction needs]

## 7. Interaction and Animation Guidelines
### [Interaction requirements]
- **Micro-interactions**: [Specific animations needed]
- **Page Transitions**: [Navigation transitions]
- **Loading States**: [Progress indicators]

## 8. Icon System
### [Icon requirements]
- **Style**: [Icon design specifications]
- **Sizes**: [Icon size requirements]
- **Usage**: [Icon placement and purpose]

## 9. Content Guidelines
### [Content requirements]
- **Writing Principles**: [Language and tone]
- **Error Messages**: [Error handling text]
- **User Feedback**: [Success and notification text]

## 10. Performance Considerations
### [Performance requirements]
- **Image Optimization**: [Asset optimization]
- **Component Reusability**: [Code efficiency]
- **Loading Performance**: [Speed requirements]

## 11. Quality Assurance Checklist
### [QA requirements]
- [ ] [Specific checklist items based on user story]
- [ ] [Accessibility requirements]
- [ ] [Testing requirements]
- [ ] [Brand consistency requirements]

## Implementation Notes
1. **Specific Requirements**: [Implementation details]
2. **Testing Criteria**: [Testing requirements]
3. **Delivery Timeline**: [Timeline considerations]
4. **Success Metrics**: [How to measure success]

The prompt should be categorized as: Development, Testing, DevOps, Documentation, or Design

Format your response as JSON:
{
  "title": "string",
  "content": "string",
  "category": "Development|Testing|DevOps|Documentation|Design",
  "tags": ["tag1", "tag2", "tag3"],
  "estimatedEffort": "string",
  "priority": "high|medium|low"
}
`;

    const response = await llm.invoke(prompt);
    const result = JSON.parse(response.content);

    // Validate response structure
    if (!result.title || !result.content || !result.category || !result.tags) {
      throw new Error("Invalid AI response structure for prompt");
    }

    return result;
  } catch (error) {
    // Fallback response
    return {
      title: `Enterprise Design Guidelines for ${userStory.title}`,
      content: `# Enterprise Application Design Guidelines for ${userStory.title}

## Project Overview
Create comprehensive design guidelines for the functionality described in the user story: ${userStory.description}

## 1. Design System Foundation
### Brand Identity
- **Logo Integration**: Implement company logo with proper sizing
- **Brand Colors**: Define primary, secondary, and neutral color palettes
- **Brand Voice**: Maintain professional, trustworthy tone
- **Typography Hierarchy**: Establish clear heading levels

## 2. Typography Guidelines
### Font Selection
- **Primary Font**: Choose enterprise-grade typeface
- **Font Weights**: Regular (400), Medium (500), Semi-bold (600), Bold (700)
- **Line Heights**: 1.2 for headings, 1.4-1.6 for body text

## 3. Layout and Grid System
### Grid Structure
- **Desktop**: 12-column grid with 24px gutters
- **Tablet**: 8-column grid with 20px gutters
- **Mobile**: 4-column grid with 16px gutters

## 4. Component Library Specifications
### Core Components
- **Requirements**: Design components based on user story needs
- **States**: Include all interactive states
- **Accessibility**: Ensure WCAG 2.1 AA compliance

## 5. Web Accessibility
### Compliance Requirements
- **Contrast Ratios**: Meet WCAG AA standards
- **Keyboard Navigation**: Full keyboard support
- **Screen Reader Support**: Proper ARIA implementation

## 6. Responsive Design
### Mobile-First Approach
- **Breakpoints**: 320px, 768px, 1024px, 1200px
- **Touch Interactions**: Optimize for mobile devices
- **Content Priority**: Most important content visible first

## 7. Quality Assurance
### Checklist
- [ ] All components follow design system
- [ ] Accessibility standards met
- [ ] Responsive behavior defined
- [ ] Brand consistency maintained

## Implementation Notes
1. **Component Creation**: Build reusable components
2. **Testing**: Verify accessibility and responsiveness
3. **Documentation**: Include usage guidelines
4. **Delivery**: Ensure timely completion`,
      category: "Design",
      tags: ["design", "enterprise", "guidelines", "user-story"],
      estimatedEffort: "2-3 days",
      priority: userStory.priority || "medium",
    };
  }
};

export const generateCodeFromPrompt = async (promptContent) => {
  try {
    const prompt = `
${ANTI_HALLUCINATION_PROMPT}

Based on the following Enterprise Application Design Guidelines prompt, generate clean, production-ready code that implements the design specifications:

Prompt: ${promptContent}

Generate code that:
1. Follows the Enterprise Design Guidelines structure provided
2. Implements all specified design system components
3. Includes proper accessibility features (WCAG 2.1 AA compliance)
4. Has responsive design for all specified breakpoints
5. Uses modern JavaScript/TypeScript/React patterns
6. Includes proper error handling and validation
7. Has clear documentation and comments
8. Is testable and maintainable
9. Follows insurance domain best practices
10. Implements the specified color system, typography, and spacing

Focus on creating practical, implementable code that addresses all the design requirements in the prompt.

Provide the complete implementation including:
- Component structure
- Styling (CSS/Tailwind)
- Accessibility features
- Responsive behavior
- State management
- Error handling

Format the response as a complete, runnable code example.
`;

    const response = await llm.invoke(prompt);
    return response.content;
  } catch (error) {
    return "// Error generating code\n// Please review the Enterprise Design Guidelines prompt and try again.";
  }
};

// Helper function to validate AI responses
export const validateAIResponse = (response, requiredFields) => {
  if (!response || typeof response !== "object") {
    return false;
  }

  for (const field of requiredFields) {
    if (!(field in response)) {
      return false;
    }
  }

  return true;
};

// Helper function to sanitize AI responses
export const sanitizeAIResponse = (response) => {
  if (typeof response === "string") {
    // Remove any markdown formatting that might cause issues
    return response.replace(/```[\s\S]*?```/g, "").trim();
  }

  if (typeof response === "object") {
    // Recursively sanitize object properties
    const sanitized = {};
    for (const [key, value] of Object.entries(response)) {
      sanitized[key] = sanitizeAIResponse(value);
    }
    return sanitized;
  }

  return response;
};

// Generate prompt template using Azure OpenAI
export const generatePromptTemplate = async (
  category,
  subcategory,
  description,
  additionalContext = ""
) => {
  try {
    if (!llm) {
      throw new Error("Azure OpenAI client not initialized");
    }

    console.log("Generating prompt template with Azure OpenAI...");

    const contextSection = additionalContext
      ? `
Additional Context/Requirements: ${additionalContext}`
      : "";

    const prompt = `
You are an expert business analyst and prompt engineer specializing in creating comprehensive, professional business requirements and AI prompts for various industries. 
You must respond ONLY with a valid JSON object, no additional text or formatting.

Create a detailed, professional business requirement document and AI prompt template for the ${category} industry, specifically for ${subcategory}.

Requirements:
- Industry: ${category}
- Subcategory: ${subcategory}  
- Description: ${description}${contextSection}

The prompt should include:
1. **Detailed Business Context**: Comprehensive background explaining the business need, current challenges, and industry-specific requirements
2. **User Persona**: Clear definition of who will use this (e.g., "As an actuary, I require the ability to...")
3. **Functional Requirements**: Specific capabilities and features needed, with bullet points for each major function
4. **Business Objectives**: Clear explanation of goals, benefits, and success metrics
5. **Technical Considerations**: Any relevant technical aspects, compliance requirements, or integration needs
6. **Implementation Details**: Practical considerations for deployment and usage

The output should be similar in depth and professionalism to comprehensive business requirements documents, with:
- Multiple detailed paragraphs explaining the business context
- Specific user requirements with actionable language
- Clear business objectives with measurable outcomes
- Professional terminology appropriate for the industry
- Length: 800-1500 words for comprehensive coverage

Include placeholders for user input using {VARIABLE_NAME} format where appropriate.

IMPORTANT: Respond ONLY with this exact JSON format (no markdown, no backticks, no extra text):
{
  "title": "Professional title for the business requirement/prompt",
  "category": "${subcategory}",
  "description": "Comprehensive description of what this addresses and accomplishes",
  "prompt": "The complete business requirement document with detailed context, user requirements, business objectives, and implementation considerations",
  "tags": ["industry-specific", "tag2", "tag3", "tag4", "tag5"],
  "difficulty": "Advanced",
  "estimatedTime": "30-45 min"
}
`;

    const response = await llm.invoke(prompt);
    console.log("Raw Azure OpenAI response:", response.content);

    let content = response.content.trim();

    // Clean up the response - remove markdown code blocks if present
    content = content.replace(/^```json\s*/i, "").replace(/\s*```$/, "");
    content = content.replace(/^```\s*/, "").replace(/\s*```$/, "");

    try {
      const templateData = JSON.parse(content);

      // Validate required fields
      if (!templateData.title || !templateData.prompt) {
        throw new Error("Missing required fields in generated template");
      }

      // Ensure all required fields have defaults
      return {
        id: `generated-${Date.now()}`,
        title: templateData.title || `${subcategory} Template`,
        category: templateData.category || subcategory,
        description:
          templateData.description ||
          `AI-generated template for ${subcategory}`,
        prompt: templateData.prompt || "Template generation failed",
        tags: Array.isArray(templateData.tags)
          ? templateData.tags
          : ["ai-generated"],
        difficulty: templateData.difficulty || "Intermediate",
        estimatedTime: templateData.estimatedTime || "10-15 min",
        popularity: Math.floor(Math.random() * 20) + 70,
      };
    } catch (parseError) {
      console.error("JSON Parse Error:", parseError);
      console.error("Content that failed to parse:", content);

      // Fallback: create a comprehensive template if parsing fails
      return {
        id: `generated-${Date.now()}`,
        title: `${subcategory} Business Requirements and Implementation Framework`,
        category: subcategory,
        description: `Comprehensive business requirements document for ${subcategory} implementation in the ${category} industry`,
        prompt: `# ${subcategory} Business Requirements and Implementation Framework

## Business Context and Overview

The ${category} industry requires robust solutions for ${subcategory} to address current market challenges and regulatory requirements. This comprehensive framework outlines the business need, functional requirements, and implementation strategy for modernizing ${subcategory} processes.

${
  description
    ? `

## Specific Business Challenge

${description}`
    : ""
}

${
  additionalContext
    ? `

## Additional Requirements and Context

${additionalContext}`
    : ""
}

## User Requirements

As a ${category} professional, I require the ability to:

â€¢ **Process Management**: Streamline and automate core ${subcategory} processes to improve efficiency and reduce manual errors

â€¢ **Data Integration**: Seamlessly integrate with existing systems and data sources: {DATA_SOURCES}

â€¢ **Compliance Framework**: Ensure full regulatory compliance with industry standards and requirements: {REGULATORY_REQUIREMENTS}

â€¢ **Analytics and Reporting**: Generate comprehensive reports and analytics to support decision-making: {REPORTING_REQUIREMENTS}

â€¢ **User Experience**: Provide intuitive interfaces that support various user roles and skill levels: {USER_ROLES}

â€¢ **Scalability**: Support growing business needs and increased transaction volumes: {VOLUME_REQUIREMENTS}

## Functional Requirements

### Core Functionality
1. **Data Processing**: Automated processing of {INPUT_DATA_TYPE} with validation and error handling
2. **Business Logic**: Implementation of industry-specific rules and calculations: {BUSINESS_RULES}
3. **Integration**: API-based integration with: {INTEGRATION_SYSTEMS}
4. **Security**: Role-based access control and data encryption: {SECURITY_REQUIREMENTS}

### Advanced Features
1. **Machine Learning**: Predictive analytics and pattern recognition: {ML_REQUIREMENTS}
2. **Real-time Processing**: Live data processing and immediate feedback: {REALTIME_NEEDS}
3. **Audit Trail**: Comprehensive logging and audit capabilities: {AUDIT_REQUIREMENTS}
4. **Workflow Management**: Configurable business process workflows: {WORKFLOW_SPECS}

## Business Objectives

### Primary Goals
- **Operational Efficiency**: Reduce processing time by {EFFICIENCY_TARGET}% and minimize manual intervention
- **Accuracy Improvement**: Achieve {ACCURACY_TARGET}% accuracy in automated processes
- **Compliance Assurance**: Maintain 100% compliance with {REGULATORY_STANDARDS}
- **Cost Reduction**: Decrease operational costs by {COST_SAVINGS}% through automation

### Success Metrics
- Processing time reduction: {TIME_REDUCTION_METRIC}
- Error rate improvement: {ERROR_REDUCTION_METRIC}
- User satisfaction scores: {SATISFACTION_TARGET}
- ROI achievement: {ROI_TARGET} within {TIMEFRAME}

## Technical Considerations

### Architecture Requirements
- **Scalability**: Support for {CONCURRENT_USERS} concurrent users
- **Performance**: Response times under {RESPONSE_TIME_TARGET}ms
- **Availability**: {UPTIME_REQUIREMENT}% uptime SLA
- **Data Volume**: Handle {DATA_VOLUME} transactions per {TIME_PERIOD}

### Integration Points
- **Existing Systems**: {LEGACY_SYSTEMS}
- **Third-party APIs**: {EXTERNAL_APIS}
- **Data Sources**: {DATA_REPOSITORIES}
- **Reporting Tools**: {REPORTING_PLATFORMS}

## Implementation Strategy

### Phase 1: Foundation (Weeks 1-4)
- System architecture design and setup
- Core data models and database schema
- Basic user interface framework
- Initial security implementation

### Phase 2: Core Features (Weeks 5-8)
- Primary business logic implementation
- Data processing workflows
- User management and authentication
- Basic reporting capabilities

### Phase 3: Advanced Features (Weeks 9-12)
- Machine learning model integration
- Advanced analytics and dashboards
- Workflow automation
- Performance optimization

### Phase 4: Testing and Deployment (Weeks 13-16)
- Comprehensive testing and validation
- User acceptance testing
- Production deployment
- Training and documentation

## Risk Mitigation

- **Data Quality**: Implement robust data validation and cleansing procedures
- **Change Management**: Comprehensive user training and change management processes
- **Security**: Multi-layered security approach with regular audits
- **Performance**: Load testing and performance monitoring throughout development

## Success Criteria

The implementation will be considered successful when:
- All functional requirements are met and validated
- Performance benchmarks are achieved
- User acceptance criteria are satisfied
- Regulatory compliance is verified
- Business objectives are measurably improved

This framework provides the foundation for implementing a comprehensive ${subcategory} solution that addresses current business needs while positioning for future growth and adaptation.`,
        tags: [
          category.toLowerCase(),
          subcategory.toLowerCase().replace(" ", "-"),
          "business-requirements",
          "comprehensive",
          "fallback",
        ],
        difficulty: "Advanced",
        estimatedTime: "30-45 min",
        popularity: Math.floor(Math.random() * 20) + 70,
      };
    }
  } catch (error) {
    console.error("Error generating prompt template:", error);

    // Fallback template if AI service fails
    return {
      id: `generated-${Date.now()}`,
      title: `${subcategory} Template`,
      category: subcategory,
      description: `Professional template for ${subcategory} in ${category}`,
      prompt: `You are a ${category} expert specializing in ${subcategory}. 

Please help with the following task:

1. **Analysis**: Review the provided information: {INPUT_DATA}
2. **Assessment**: Evaluate the key factors and requirements
3. **Recommendations**: Provide actionable recommendations
4. **Next Steps**: Outline the next steps to take

Please provide a comprehensive response with clear explanations and actionable insights.

Task Details: ${description}`,
      tags: [
        category.toLowerCase(),
        subcategory.toLowerCase().replace(" ", "-"),
        "fallback",
      ],
      difficulty: "Intermediate",
      estimatedTime: "10-15 min",
      popularity: Math.floor(Math.random() * 20) + 70,
    };
  }
};

// Backend prompt generation function
export const generateBackendPrompt = async (
  requirements,
  language,
  framework,
  database,
  cloud,
  projectName,
  projectDescription,
  additionalRequirements
) => {
  try {
    if (!llm) {
      throw new Error("Azure OpenAI client not initialized");
    }

    console.log("Generating backend prompt with Azure OpenAI...");

    const prompt = `
${ANTI_HALLUCINATION_PROMPT}

Generate a comprehensive enterprise-level backend development prompt in the EXACT format shown below. Follow this structure precisely. In addition to the narrative prompt, ALSO produce a Cursor-ready scaffolding payload so the folder structure and starter files can be created directly.

**Project Details:**
- Project Name: ${projectName || "backend-project"}
- Description: ${projectDescription || "Backend API"}
- Language: ${language}
- Framework: ${framework}
- Database: ${database || "None specified"}
- Cloud Platform: ${cloud || "None specified"}

**Requirements:**
${requirements}

**Additional Requirements:**
${additionalRequirements || "None specified"}

**Instructions:**
Generate a detailed enterprise-level backend prompt that follows this EXACT structure:

1. Start with "# Enterprise Backend Development Prompt"
2. Include "## Project Overview" with project details
3. Add "## Technology Stack" section
4. Include "## Requirements Analysis" section
5. Add "## Enterprise Folder Structure" with a fully nested, annotated folder tree. Show every directory and its immediate child files/folders using an ASCII tree (â”œâ”€â”€, â””â”€â”€) with inline comments describing the purpose of each item. Include at least these folders: src, controllers, models, routes, services, utils, config, test. Under each, list 2-5 representative files (e.g., index.js, health.js, db.js) with one-line purposes.
   Also append a short "File-to-Folder Mapping" list that explains which types of files belong in which folder and why.
6. Include "## Implementation Guidelines" with 8 subsections
7. Add "## Quality Standards" section
8. Include "## Next Steps" section
9. Add "## Key Features of the Generated Prompt" with 5 subsections

STYLE REQUIREMENT: Write the entire prompt as a descriptive story, not as a dry checklist. Use rich, narrative paragraphs that read like a lead engineer's blueprint memo. Weave in business context, actors/personas, a day-in-the-life scenario, the problem tension, architectural decisions, and the resolution through the proposed structure. Each section should contain 2-4 paragraphs of cohesive prose before any lists. Prefer full sentences and transitions; keep bullets only where they add clarity (e.g., risks, acceptance).

Incorporate:
- Clear business backdrop and why the system matters now
- Primary personas (e.g., Claims Intake Specialist, API Platform Engineer)
- End-to-end flow narrative from request to persistence to monitoring
- Architectural decisions and their trade-offs
- Operational excellence (observability, resiliency patterns, rollback story)
- Security posture as part of the storyline (authz/authn, data privacy)

The prompt should be comprehensive, detailed, and follow enterprise standards for ${language} and ${framework} while maintaining the narrative tone.

Then, based on the same inputs, produce a scaffolding payload suitable for automatic application in a code editor. The payload MUST:
- Be valid JSON
- Contain a \`scaffold\` field with a bash script that uses mkdir, echo, and tee to create the directory tree and empty files
- Contain a \`files\` array of objects with fields: { "path": string, "content": string } for minimal starter files (e.g., entrypoint, config, example route, env example, README)
- Only include 8-20 essential files to keep it lightweight
- Use forward slashes for paths and no leading slashes

Format your response as JSON:
{
  "prompt": "Complete enterprise-level folder structure prompt following the exact format structure",
  "folderStructure": "Detailed project folder structure in text format",
  "features": ["Comprehensive Project Structure", "Technology-Specific Guidance", "Security & Quality", "Documentation & Maintenance", "DevOps Integration"],
  "technologies": ["list", "of", "technologies", "and", "tools", "mentioned"],
  "bestPractices": ["list", "of", "best", "practices", "included"],
  "scaffold": "bash script that creates the folders/files",
  "files": [
    { "path": "src/index.${
      language === "typescript" ? "ts" : "js"
    }", "content": "// minimal web server bootstrap" },
    { "path": "src/routes/health.${
      language === "typescript" ? "ts" : "js"
    }", "content": "// health route" },
    { "path": ".env.example", "content": "PORT=3000\nNODE_ENV=development" },
    { "path": "README.md", "content": "# ${
      projectName || "backend-project"
    }\n\nGenerated scaffold. Follow the prompt below to implement remaining pieces." }
  ]
}
`;

    const response = await llm.invoke(prompt);
    console.log("Azure OpenAI response received:", response);

    let result;
    try {
      result = JSON.parse(response.content);
    } catch (parseError) {
      throw new Error("Invalid JSON response from AI service");
    }

    // Validate response structure
    if (!result.prompt) {
      throw new Error("Invalid AI response structure - missing prompt");
    }

    console.log("Successfully generated backend prompt:", result);
    return result;
  } catch (error) {
    console.error("Error generating backend prompt:", error);

    // Fallback response
    const projectNameValue = projectName || "backend-project";
    const projectDescValue = projectDescription || "Backend API";
    const databaseValue = database || "To be determined";
    const cloudValue = cloud !== "none" ? cloud : "On-premise deployment";
    const additionalReqs = additionalRequirements
      ? `**Additional Requirements:**\n${additionalRequirements}`
      : "";

    const folderStructureText = `${projectNameValue}/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/          # API route handlers
â”‚   â”‚   â”œâ”€â”€ authController.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ userController.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ healthController.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ models/              # Data models and schemas
â”‚   â”‚   â”œâ”€â”€ User.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ Auth.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ index.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ services/            # Business logic layer
â”‚   â”‚   â”œâ”€â”€ authService.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ userService.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ emailService.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ middleware/          # Custom middleware functions
â”‚   â”‚   â”œâ”€â”€ auth.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ validation.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ errorHandler.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ utils/               # Utility functions and helpers
â”‚   â”‚   â”œâ”€â”€ logger.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ database.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ helpers.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ config/              # Configuration management
â”‚   â”‚   â”œâ”€â”€ database.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ app.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ env.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ routes/              # API route definitions
â”‚   â”‚   â”œâ”€â”€ auth.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â”œâ”€â”€ users.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ health.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ validators/          # Input validation schemas
â”‚   â”‚   â”œâ”€â”€ authValidator.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ userValidator.${language === "typescript" ? "ts" : "js"}
â”‚   ${
      language === "typescript"
        ? "â”œâ”€â”€ types/               # TypeScript type definitions\nâ”‚   â”œâ”€â”€ auth.types.ts\nâ”‚   â”œâ”€â”€ user.types.ts\nâ”‚   â””â”€â”€ common.types.ts\n"
        : ""
    }â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/                # Unit tests
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”œâ”€â”€ integration/         # Integration tests
â”‚   â”‚   â”œâ”€â”€ auth.test.${language === "typescript" ? "ts" : "js"}
â”‚   â”‚   â””â”€â”€ users.test.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ e2e/                 # End-to-end tests
â”‚   â”‚   â””â”€â”€ api.test.${language === "typescript" ? "ts" : "js"}
â”‚   â””â”€â”€ fixtures/            # Test data and fixtures
â”‚       â”œâ”€â”€ users.json
â”‚       â””â”€â”€ auth.json
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ api/                 # API documentation
â”‚   â”‚   â”œâ”€â”€ auth.md
â”‚   â”‚   â””â”€â”€ users.md
â”‚   â”œâ”€â”€ architecture/        # System architecture docs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ deployment/          # Deployment guides
â”‚       â”œâ”€â”€ docker.md
â”‚       â””â”€â”€ production.md
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ build/               # Build scripts
â”‚   â”‚   â””â”€â”€ build.sh
â”‚   â”œâ”€â”€ deployment/          # Deployment scripts
â”‚   â”‚   â””â”€â”€ deploy.sh
â”‚   â””â”€â”€ database/            # Database migration scripts
â”‚       â”œâ”€â”€ migrate.js
â”‚       â””â”€â”€ seed.js
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ development/         # Development configuration
â”‚   â”‚   â””â”€â”€ config.${language === "typescript" ? "ts" : "js"}
â”‚   â”œâ”€â”€ production/          # Production configuration
â”‚   â”‚   â””â”€â”€ config.${language === "typescript" ? "ts" : "js"}
â”‚   â””â”€â”€ testing/             # Testing configuration
â”‚       â””â”€â”€ config.${language === "typescript" ? "ts" : "js"}
â”œâ”€â”€ .github/                 # GitHub workflows and templates
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml
â”‚       â””â”€â”€ deploy.yml
â”œâ”€â”€ .docker/                 # Docker configuration
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ docker-compose.yml
â”œâ”€â”€ .env.example             # Environment variables template
â”œâ”€â”€ .gitignore               # Git ignore rules
â”œâ”€â”€ package.json             # Dependencies and scripts
â”œâ”€â”€ README.md                # Project documentation
${
  language === "typescript"
    ? "â”œâ”€â”€ tsconfig.json            # TypeScript configuration\nâ”œâ”€â”€ jest.config.js            # Jest testing configuration\n"
    : "â”œâ”€â”€ jest.config.js            # Jest testing configuration\n"
}â””â”€â”€ CHANGELOG.md             # Version history

File-to-Folder Mapping:
- Controllers: Business logic for each endpoint
- Models: Data structures and schema definitions
- Routes: API endpoint definitions
- Services: Business logic abstraction layer
- Utils: Utility functions
- Config: Configuration settings
- Test: Unit and integration tests`;

    const databaseSection = database
      ? `- Set up ${database} connection and configuration
- Implement database models and migrations
- Add database connection pooling
- Include database health checks`
      : `- Implement database abstraction layer
- Add support for multiple database types
- Include database migration system`;

    const devopsSection =
      cloud !== "none"
        ? `- Set up ${cloud} deployment pipeline
- Configure CI/CD workflows
- Add monitoring and logging
- Implement health checks and metrics`
        : `- Set up local development environment
- Configure build and deployment scripts
- Add monitoring and logging capabilities`;

    const promptText = `# Enterprise Backend Development Prompt

## Project Overview
Create a production-ready ${framework} backend application using ${language} for ${projectNameValue}.

**Project Description:** ${projectDescValue}

## Technology Stack
- **Language:** ${language}
- **Framework:** ${framework}
- **Database:** ${databaseValue}
- **Cloud Platform:** ${cloudValue}

## Requirements Analysis
${requirements}

${additionalReqs}

## Enterprise Folder Structure

Create the following comprehensive project structure:

\`\`\`text
${folderStructureText}
\`\`\`

## Implementation Guidelines

### 1. Project Setup
- Initialize the project with proper package management
- Set up TypeScript configuration (if using TypeScript)
- Configure ESLint and Prettier for code quality
- Set up Jest or similar testing framework

### 2. Core Architecture
- Implement clean architecture principles
- Separate concerns into distinct layers
- Use dependency injection for better testability
- Implement proper error handling and logging

### 3. API Development
- Design RESTful API endpoints
- Implement proper HTTP status codes
- Add request/response validation
- Include API versioning strategy

### 4. Database Integration
${databaseSection}

### 5. Security Implementation
- Implement authentication and authorization
- Add input validation and sanitization
- Include rate limiting and CORS configuration
- Add security headers and HTTPS enforcement

### 6. Testing Strategy
- Write comprehensive unit tests
- Implement integration tests
- Add end-to-end testing
- Include performance testing

### 7. Documentation
- Create comprehensive API documentation
- Add code comments and JSDoc
- Include setup and deployment guides
- Document environment variables and configuration

### 8. DevOps Integration
${devopsSection}

## Quality Standards
- Follow ${language} best practices and coding standards
- Implement proper error handling and logging
- Add comprehensive input validation
- Include security best practices
- Ensure code is maintainable and scalable
- Add proper documentation and comments

## Next Steps
1. Set up the project structure
2. Install and configure dependencies
3. Implement core functionality
4. Add testing and documentation
5. Deploy and monitor the application

This prompt provides a comprehensive guide for creating an enterprise-level backend application with proper structure, security, and maintainability.

---

## Key Features of the Generated Prompt:

### ğŸ—ï¸ **Comprehensive Structure**
- **Detailed folder organization** with clear purposes for each directory
- **Enterprise-level patterns** following industry best practices
- **Scalable architecture** that can grow with the project

### ğŸ”§ **Technology-Specific Guidance**
- **Framework-specific patterns** (${framework} in this example)
- **Database integration** (${databaseValue} with proper connection handling)
- **Cloud deployment** (${cloudValue} with CI/CD pipelines)

### ğŸ›¡ï¸ **Security & Quality**
- **Authentication & authorization** patterns
- **Input validation** and sanitization
- **Error handling** and logging strategies
- **Testing strategies** (unit, integration, e2e)

### ğŸ“š **Documentation & Maintenance**
- **API documentation** with Swagger
- **Architecture documentation**
- **Deployment guides**
- **Code quality standards**

### ğŸš€ **DevOps Integration**
- **CI/CD workflows** with GitHub Actions
- **Docker containerization**
- **Environment configuration**
- **Monitoring and health checks**

This is exactly the type of detailed, enterprise-level prompt that the Backend Prompt Generator creates - it provides developers with a complete roadmap for building production-ready backend applications with proper structure, security, and maintainability standards.`;

    // Generate scaffold script
    const scaffoldScript = `#!/bin/bash
# Scaffold script for ${projectNameValue}
# Generated by Backend Prompt Generator

echo "Creating project structure for ${projectNameValue}..."

# Create main directories
mkdir -p ${projectNameValue}
cd ${projectNameValue}

# Create src directory structure
mkdir -p src/controllers
mkdir -p src/models
mkdir -p src/services
mkdir -p src/middleware
mkdir -p src/utils
mkdir -p src/config
mkdir -p src/routes
mkdir -p src/validators
${language === "typescript" ? "mkdir -p src/types" : ""}

# Create test directory structure
mkdir -p tests/unit/controllers
mkdir -p tests/unit/services
mkdir -p tests/unit/utils
mkdir -p tests/integration
mkdir -p tests/e2e
mkdir -p tests/fixtures

# Create documentation structure
mkdir -p docs/api
mkdir -p docs/architecture
mkdir -p docs/deployment

# Create scripts structure
mkdir -p scripts/build
mkdir -p scripts/deployment
mkdir -p scripts/database

# Create config structure
mkdir -p config/development
mkdir -p config/production
mkdir -p config/testing

# Create CI/CD structure
mkdir -p .github/workflows
mkdir -p .docker

# Create essential files
touch src/index.${language === "typescript" ? "ts" : "js"}
touch src/routes/health.${language === "typescript" ? "ts" : "js"}
touch src/controllers/authController.${language === "typescript" ? "ts" : "js"}
touch src/controllers/userController.${language === "typescript" ? "ts" : "js"}
touch src/models/User.${language === "typescript" ? "ts" : "js"}
touch src/services/authService.${language === "typescript" ? "ts" : "js"}
touch src/middleware/auth.${language === "typescript" ? "ts" : "js"}
touch src/utils/logger.${language === "typescript" ? "ts" : "js"}
touch src/config/database.${language === "typescript" ? "ts" : "js"}
touch .env.example
touch .gitignore
touch README.md
touch CHANGELOG.md
touch package.json
${language === "typescript" ? "touch tsconfig.json" : ""}
touch jest.config.js

# Create Docker files
touch .docker/Dockerfile
touch .docker/docker-compose.yml

# Create GitHub workflow files
touch .github/workflows/ci.yml
touch .github/workflows/deploy.yml

# Create script files
touch scripts/build/build.sh
touch scripts/deployment/deploy.sh
touch scripts/database/migrate.js
touch scripts/database/seed.js

# Create documentation files
touch docs/api/auth.md
touch docs/api/users.md
touch docs/architecture/README.md
touch docs/deployment/docker.md
touch docs/deployment/production.md

# Create test files
touch tests/integration/auth.test.${language === "typescript" ? "ts" : "js"}
touch tests/integration/users.test.${language === "typescript" ? "ts" : "js"}
touch tests/e2e/api.test.${language === "typescript" ? "ts" : "js"}
touch tests/fixtures/users.json
touch tests/fixtures/auth.json

# Make scripts executable
chmod +x scripts/build/build.sh
chmod +x scripts/deployment/deploy.sh

echo "Project structure created successfully!"
echo "Next steps:"
echo "1. Install dependencies: npm install"
echo "2. Configure environment variables: cp .env.example .env"
echo "3. Implement core functionality"
echo "4. Add tests and documentation"
echo "5. Run tests: npm test"
echo "6. Start development server: npm run dev"`;

    // Generate essential files
    const fileExtension = language === "typescript" ? "ts" : "js";
    const files = [
      {
        path: `src/index.${fileExtension}`,
        content: `// Main application entry point
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Health check route
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: '${projectNameValue}'
  });
});

// Start server
app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
});

export default app;`,
      },
      {
        path: `src/routes/health.${fileExtension}`,
        content: `// Health check route
import express from 'express';

const router = express.Router();

router.get('/', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    service: '${projectNameValue}',
    version: '1.0.0'
  });
});

export default router;`,
      },
      {
        path: ".env.example",
        content: `# Environment Configuration
PORT=3000
NODE_ENV=development

# Database Configuration
${
  database !== "none"
    ? `DB_HOST=localhost
DB_PORT=5432
DB_NAME=${projectNameValue}
DB_USER=your_username
DB_PASSWORD=your_password`
    : "# Add your database configuration here"
}

# JWT Configuration
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=24h

# API Configuration
API_VERSION=v1
API_PREFIX=/api

# Logging
LOG_LEVEL=info
LOG_FORMAT=combined

# Security
BCRYPT_ROUNDS=12
RATE_LIMIT_WINDOW=15
RATE_LIMIT_MAX=100`,
      },
      {
        path: "README.md",
        content: `# ${projectNameValue}

${projectDescription || "A backend API project"}

## Technology Stack

- **Language:** ${language}
- **Framework:** ${framework}
- **Database:** ${database || "To be determined"}
- **Cloud Platform:** ${cloud !== "none" ? cloud : "On-premise deployment"}

## Project Structure

\`\`\`
${folderStructureText}
\`\`\`

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- ${database !== "none" ? database : "Database of your choice"}

### Installation

1. Clone the repository
2. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

3. Copy environment variables:
   \`\`\`bash
   cp .env.example .env
   \`\`\`

4. Configure your environment variables in \`.env\`

5. Start the development server:
   \`\`\`bash
   npm run dev
   \`\`\`

## API Endpoints

- \`GET /health\` - Health check endpoint
- \`GET /api/v1/\` - API base endpoint

## Development

### Running Tests

\`\`\`bash
npm test
\`\`\`

### Building for Production

\`\`\`bash
npm run build
\`\`\`

## Deployment

${
  cloud !== "none"
    ? `Deploy to ${cloud} using the provided deployment scripts.`
    : "Configure deployment scripts for your target environment."
}

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## License

This project is licensed under the MIT License.`,
      },
      {
        path: "package.json",
        content: `{
  "name": "${projectNameValue}",
  "version": "1.0.0",
  "description": "${projectDescription || "A backend API project"}",
  "main": "src/index.${fileExtension}",
  "scripts": {
    "start": "node src/index.${fileExtension}",
    "dev": "nodemon src/index.${fileExtension}",
    "build": "npm run build:${language === "typescript" ? "ts" : "js"}",
    ${language === "typescript" ? `"build:ts": "tsc",` : ""}
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "format": "prettier --write src/"
  },
  "keywords": [
    "backend",
    "api",
    "${framework.toLowerCase()}",
    "${language}"
  ],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "dotenv": "^16.3.1"${
      database !== "none"
        ? `,
    "${
      database === "postgresql"
        ? "pg"
        : database === "mongodb"
        ? "mongoose"
        : database === "mysql"
        ? "mysql2"
        : "database-driver"
    }": "^latest"`
        : ""
    }
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.2",
    "supertest": "^6.3.3",
    "eslint": "^8.45.0",
    "prettier": "^3.0.0"${
      language === "typescript"
        ? `,
    "typescript": "^5.1.6",
    "@types/node": "^20.4.5",
    "@types/express": "^4.17.17",
    "@types/cors": "^2.8.13",
    "@types/jest": "^29.5.3"`
        : ""
    }
  },
  "engines": {
    "node": ">=16.0.0"
  }
}`,
      },
    ];

    return {
      prompt: promptText,
      folderStructure: folderStructureText,
      features: [
        "Comprehensive Project Structure",
        "Technology-Specific Guidance",
        "Security & Quality",
        "Documentation & Maintenance",
        "DevOps Integration",
      ],
      technologies: [
        language,
        framework,
        database || "Database-agnostic",
        cloud !== "none" ? cloud : "On-premise",
      ],
      bestPractices: [
        "Clean architecture",
        "Error handling",
        "Input validation",
        "Security patterns",
        "Code quality standards",
        "Performance optimization",
      ],
      scaffold: scaffoldScript,
      files: files,
    };
  }
};

// Generate backend folder structure
export const generateBackendFolderStructure = async (
  language,
  framework,
  projectType
) => {
  try {
    if (!llm) {
      throw new Error("Azure OpenAI client not initialized");
    }

    const prompt = `
Generate a standard folder structure for a ${language} backend project using ${framework}.

Project Type: ${projectType || "REST API"}

Include:
1. Standard folder organization
2. Configuration files
3. Documentation structure
4. Test organization
5. Deployment files
6. Environment configuration

Return the folder structure in a clear, hierarchical text format.
`;

    const response = await llm.invoke(prompt);
    return response.content;
  } catch (error) {
    console.error("Error generating folder structure:", error);

    // Fallback folder structures for common languages
    const fallbackStructures = {
      javascript: `project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ services/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ config/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â””â”€â”€ integration/
â”œâ”€â”€ docs/
â”œâ”€â”€ scripts/
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package.json
â””â”€â”€ README.md`,
      typescript: `project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ types/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ config/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â””â”€â”€ integration/
â”œâ”€â”€ docs/
â”œâ”€â”€ scripts/
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md`,
      python: `project-root/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ services/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ config/
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â””â”€â”€ integration/
â”œâ”€â”€ docs/
â”œâ”€â”€ scripts/
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md`,
    };

    return fallbackStructures[language] || fallbackStructures["javascript"];
  }
};

// Test function to verify Azure OpenAI connection
export const testAzureOpenAIConnection = async () => {
  if (!llm) {
    return { success: false, message: "Azure OpenAI client not initialized" };
  }

  try {
    console.log("Testing Azure OpenAI connection...");
    const testResponse = await llm.invoke(
      'Hello, this is a test message. Please respond with "Connection successful".'
    );
    console.log("Test response received:", testResponse);

    return {
      success: true,
      message: "Connection successful",
      response: testResponse.content,
    };
  } catch (error) {
    return {
      success: false,
      message: "Connection failed",
      error: error,
    };
  }
};
